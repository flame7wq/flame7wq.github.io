<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <meta name="description" content="Practical Malware Analysis The Hands-On Guide to Dissecting Malicious Software
恶意代码分析实战期末复习笔记 by757" />
  

  
  
  
  
  
  
  <title>恶意代码分析实战笔记 | QiShengjia</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Practical Malware Analysis The Hands-On Guide to Dissecting Malicious Software 恶意代码分析实战期末复习笔记 by757">
<meta property="og:type" content="article">
<meta property="og:title" content="恶意代码分析实战笔记">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;2019&#x2F;12&#x2F;26&#x2F;%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0&#x2F;index.html">
<meta property="og:site_name" content="QiShengjia">
<meta property="og:description" content="Practical Malware Analysis The Hands-On Guide to Dissecting Malicious Software 恶意代码分析实战期末复习笔记 by757">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;flame7wq&#x2F;MarkdownPic&#x2F;master&#x2F;Image.png">
<meta property="og:updated_time" content="2019-12-27T00:37:26.240Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;flame7wq&#x2F;MarkdownPic&#x2F;master&#x2F;Image.png">
  
  
    <link rel="icon" href="/css/images/favicon.ico">
  
  <link rel="stylesheet" href="/css/style.css">
  

  
  <!-- baidu webmaster push -->
  <script src='//push.zhanzhang.baidu.com/push.js'></script>
</head>
<body class="home blog custom-background custom-font-enabled single-author">
  <div id="page" class="hfeed site">
      <header id="masthead" class="site-header" role="banner">
    <hgroup>
      <h1 class="site-title">
        <a href="/" title="QiShengjia" rel="home">QiShengjia</a>
      </h1>
      
        <h2 class="site-description">
          <a href="/" id="subtitle">心无所恃，随遇而安</a>
        </h2>
      
    </hgroup>

    <nav id="site-navigation" class="main-navigation" role="navigation">
            <button class="menu-toggle">菜单</button>
            <a class="assistive-text" href="/#content" title="跳至内容">跳至内容</a><!--TODO-->
            <div class="menu-main-container">
                <ul id="menu-main" class="nav-menu">
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/">Home</a></li>
                
                    <li class="menu-item menu-item-type-post_type menu-item-object-page"><a href="/archives">Archives</a></li>
                
                </ul>
            </div>
    </nav>
</header>

      <div id="main" class="wrapper">
        <div id="primary" class="site-content"><div id="content" role="main"><article id="post-恶意代码分析实战笔记" class="post-恶意代码分析实战笔记 post type-post status-publish format-standard hentry">
    <!---->

      <header class="entry-header">
        
        
  
    <h1 class="entry-title article-title">
      恶意代码分析实战笔记
    </h1>
  

        
        <div class="comments-link">
            
            <a href="javascript:void(0);" data-url="http://yoursite.com/2019/12/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/" data-id="ck4mrua8o00009wutfyaqgsgv" class="leave-reply bdsharebuttonbox" data-cmd="more">Share</a>
        </div><!-- .comments-link -->
      </header><!-- .entry-header -->

    <div class="entry-content">
      
        <p>Practical Malware Analysis The Hands-On Guide to Dissecting Malicious Software</p>
<p>恶意代码分析实战期末复习笔记 by757</p>
<a id="more"></a>
<h1 id="Chapter-0-入门"><a href="#Chapter-0-入门" class="headerlink" title="Chapter 0 入门"></a>Chapter 0 入门</h1><h2 id="恶意代码分析目标"><a href="#恶意代码分析目标" class="headerlink" title="恶意代码分析目标"></a>恶意代码分析目标</h2><p>定位感染的主机和文件，确定可疑二进制程序做了什么，如何在网络上检测，如何消除带来的损害。</p>
<p>编写检测特征码来检测出网络中被感染的主机</p>
<ul>
<li>基于主机的检测特征码 Host-based signatures<ul>
<li>恶意代码创建或修改的文件</li>
<li>注册表的修改</li>
<li>……</li>
</ul>
</li>
<li>基于网络的检测特征码 Network signatures<ul>
<li>通过检测网络流量</li>
</ul>
</li>
</ul>
<h2 id="恶意代码分析技术"><a href="#恶意代码分析技术" class="headerlink" title="恶意代码分析技术"></a>恶意代码分析技术</h2><p>基本方法：</p>
<ul>
<li>静态分析Static analysis （without running malware）</li>
<li>动态分析Dynamic analysis （running it）</li>
</ul>
<p>又进一步分为基础技术与高级技术</p>
<h2 id="恶意代码类型"><a href="#恶意代码类型" class="headerlink" title="恶意代码类型"></a>恶意代码类型</h2><ul>
<li>后门 Backdoor</li>
<li>僵尸网络 Botnet</li>
<li>下载器 Downloader</li>
<li>间谍软件 Information-stealing malware<ul>
<li>嗅探器</li>
<li>键盘记录器</li>
<li>密码哈希采集器</li>
</ul>
</li>
<li>启动器 Launcher<ul>
<li>用来启动其他恶意代码</li>
</ul>
</li>
<li>内核套件 Rootkit<ul>
<li>用来隐藏其他恶意代码的恶意代码</li>
</ul>
</li>
<li>勒索软件 Scareware</li>
<li>发送垃圾邮件的恶意代码 Spam-sending malware</li>
<li>蠕虫或计算机病毒 Worm or virus</li>
</ul>
<p>恶意代码经常会跨越多个类别。</p>
<p>恶意代码还可根据攻击者的类型分为大众性的和针对性的两类。<br>前者如勒索软件，撒网捞鱼，这类普遍但不复杂。<br>后者如特制后门，不广泛传播，威胁大且复杂。</p>
<h2 id="恶意代码分析通用规则"><a href="#恶意代码分析通用规则" class="headerlink" title="恶意代码分析通用规则"></a>恶意代码分析通用规则</h2><ol>
<li>不要过于陷入细节，进入细节钱有一个概要性的了解</li>
<li>使用不同的工具和方法</li>
<li>认识、理解和战胜新技术，并快速应对恶意代码分析艺术的新变化</li>
</ol>
<h1 id="Chapter1-静态分析基础技术"><a href="#Chapter1-静态分析基础技术" class="headerlink" title="Chapter1 静态分析基础技术"></a>Chapter1 静态分析基础技术</h1><p>BASIC STATIC TECHNIQUES：</p>
<ul>
<li>使用反病毒软件确认程序样本的恶意性</li>
<li>使用哈希来识别恶意代码</li>
<li>从文件的字符串列表，函数和文件头信息中发掘有用的信息</li>
</ul>
<h2 id="反病毒引擎扫描"><a href="#反病毒引擎扫描" class="headerlink" title="反病毒引擎扫描"></a>反病毒引擎扫描</h2><p>第一步最好拿多个反病毒软件扫描样本文件，看是否有反病毒引擎已经识别它。<br>常见的反病毒软件网站有<a href="https://www.virustotal.com/gui/home/upload" target="_blank" rel="noopener">VirusTotal</a>和<a href="https://www.virscan.org/" target="_blank" rel="noopener">VirSCAN</a><br>它们会根据扫描情况生成报告</p>
<p>反病毒软件并不完美，它们主要依靠一个已知恶意代码可识别片段的特征数据库（病毒文件特征库），以及基于行为和模式匹配的分析（启发式检测）来识别可疑文件。</p>
<p>so，恶意代码编写者可以轻易的进行修改来绕过检测</p>
<h2 id="Hashing-A-Fingerprint-for-Malware"><a href="#Hashing-A-Fingerprint-for-Malware" class="headerlink" title="Hashing: A Fingerprint for Malware"></a>Hashing: A Fingerprint for Malware</h2><p>哈希是一种用来唯一标识恶意代码的常用方法，产生哈希值（类似于指纹）<br>MD5 、 SHA-1 、 SHA-256 …</p>
<p>免费工具：mde5deep、WinMD5</p>
<ul>
<li>哈希值作为标签使用</li>
<li>与其他分析师分享，帮助他们识别恶意代码</li>
<li>在线搜索哈希值，看文件是否已被识别</li>
</ul>
<h2 id="查找字符串"><a href="#查找字符串" class="headerlink" title="查找字符串"></a>查找字符串</h2><p>工具：Strings</p>
<blockquote>
<p>微软使用“双字节字符串”（wide character string）描述Windows系统中实现的Unicode字符串。</p>
</blockquote>
<p>ASCII和Unicode存储字符序列时都以NULL结束，前者使用1个字节，后者则为两个字节</p>
<p>有时Strings检测出的并非真正的字符串，如内存地址、CPU指令序列、数据</p>
<p>Windows函数名通常以打大写字母开头后面单词的首字母均大写</p>
<h2 id="Packed-and-Obfuscated-Malware"><a href="#Packed-and-Obfuscated-Malware" class="headerlink" title="Packed and Obfuscated Malware"></a>Packed and Obfuscated Malware</h2><p>恶意代码使用加壳或混淆技术进行压缩，使得很难被检测和分析</p>
<blockquote>
<p>Packed and obfuscated code will often include at least the functions <strong>LoadLibrary</strong> and <strong>GetProcAddress</strong>, which are used to load and gain access to additional functions.</p>
</blockquote>
<p>加壳的程序运行时会先运行一小段脱壳代码<br>（可执行程序源文件的字符串列表、导入表和其他信息都被压缩了）</p>
<p>PEiD检测加壳<br>该工具可识别编译器和加壳器</p>
<p><a href="https://upx.github.io/" target="_blank" rel="noopener">UPX</a>为常见的的加壳工具，可下载进行脱壳<br><code>upx -d PackedProgram.exe</code></p>
<h2 id="PE文件格式"><a href="#PE文件格式" class="headerlink" title="PE文件格式"></a>PE文件格式</h2><p>可移植执行（Portable Executable）文件格式是Windows可执行文件、对象代码和DLL所使用的标准格式。实质上是一种数据结构。</p>
<p>PE文件以文件头开始，其中包括代码信息、应用程序类型、所需库函数和空间要求。  PE文件头信息价值高。</p>
<h2 id="链接库与函数"><a href="#链接库与函数" class="headerlink" title="链接库与函数"></a>链接库与函数</h2><p>可执行程序大的导入表信息极具价值，导入函数是存储在另一个程序中的函数。<br>常见函数链接方式有：</p>
<ul>
<li>静态链接</li>
<li>运行时链接</li>
<li>动态链接</li>
</ul>
<p>工具 <a href="http://www.dependencywalker.com/" target="_blank" rel="noopener">Dependency Walker</a> 可用于探索动态链接函数</p>
<p>常见的DLL程序</p>
<table>
<thead>
<tr>
<th>DLL</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>Kernel32.dll</td>
<td>access and manipulation of memory, files, and hardware</td>
</tr>
<tr>
<td>Advapi32.dll</td>
<td>access to advanced core Windows components suchas the Service Manager and Registry</td>
</tr>
<tr>
<td>User32.dll</td>
<td>contains all the user-interface components</td>
</tr>
<tr>
<td>Gdi32.dll</td>
<td>contains functions for displaying and manipulating graphics</td>
</tr>
<tr>
<td>Ntdll.dll</td>
<td>Kernel32.dll的间接导入Some tasks, such as hiding functionality or manipulating processes, will use this interface.</td>
</tr>
<tr>
<td>WSock32.dll&amp;Ws2_32.dll</td>
<td>联网，执行网络相关任务</td>
</tr>
<tr>
<td>Wininet.dll</td>
<td>包含更高层次的网络函数，实现FTP、HTTP和NTP等协议</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>函数命名约定</strong><br>微软会在更新函数后，遇到新函数与原函数不兼容且继续使用旧函数时会在函数名后加 Ex 表示新函数（CreateWindowEx），两个Ex 同理<br>以字符串作为参数的许多函数名字后面会包含一个A或者一个W（CreateDirectoryW）。这只是表面这个接受字符串参数有两个版本：A的参数类型为ASCII字符串，W为宽字符字符串。</p>
</blockquote>
<blockquote>
<p>微软通过MSDN库对Windows API 进行了出色的文档化</p>
</blockquote>
<p>Notes：</p>
<ul>
<li>导出函数是用来与其他程序交互时使用的</li>
<li>SetWindowsHookEx函数是间谍软件经常使用的函数，也是键盘记录器用来接收键盘输入最流行的方法</li>
<li>Software\Microsoft\Windows\CurrentVersion\Run 这是恶意代码非常普遍使用的注册表键值、控制Windows自启动程序</li>
<li>加壳程序比包含导入函数 LoadLibararyA 和 GetPorcAddress</li>
</ul>
<h2 id="PE文件头与分节"><a href="#PE文件头与分节" class="headerlink" title="PE文件头与分节"></a>PE文件头与分节</h2><p>the most common and interesting sections in a PE file：</p>
<table>
<thead>
<tr>
<th>Executable</th>
<th>Description</th>
</tr>
</thead>
<tbody><tr>
<td>.text</td>
<td>包含可执行代码，一般是唯一可以执行和包含代码的节</td>
</tr>
<tr>
<td>.rdata</td>
<td>包含导入与导出函数信息，以及全局可访问的只读数据</td>
</tr>
<tr>
<td>.data</td>
<td>包含全局数据</td>
</tr>
<tr>
<td>.rsrc</td>
<td>存储可执行文件所需的资源</td>
</tr>
<tr>
<td>.reloc</td>
<td>包含用来重定位库文件的信息</td>
</tr>
<tr>
<td>基于C实现，text节还可存储制度字符串（根据编译器）</td>
<td></td>
</tr>
</tbody></table>
<p>运用工具PEview 来分析PE文件<br>MAGE_OPTIONAL_HEADER项中可查看编译时间</p>
<blockquote>
<p>所有的Delphi程序都使用统一的编译时间 1992年6月19日<br>称职的编写者可以很轻易伪造编译时间</p>
</blockquote>
<p>加载过程中分配空间：Virtual Size<br>磁盘上该分节的大小规模：Size of Raw Data</p>
<blockquote>
<p>当分节在内存中叫磁盘上占更多空间Virtual Size&gt;Size of Raw Data，则往往意味着加壳代码的存在，特别是.text</p>
</blockquote>
<h3 id="资源节"><a href="#资源节" class="headerlink" title="资源节"></a>资源节</h3><p>使用工具 <a href="http://www.angusj.com/resourcehacker/" target="_blank" rel="noopener">Resource Hacker</a>浏览.rsrc节，也可查看大量的图标文件</p>
<blockquote>
<p>恶意代码经常会把一个嵌入的程序或者驱动放在资源节中，在程序运行之前，他们会将其提取出来，Resource Hacker可单独分析这些文件</p>
</blockquote>
<p>其他PE文件工具<a href="http://www.smidgeonsoft.prohosting.com/pebrowsepro-file-viewer.html" target="_blank" rel="noopener">PEBrowse Professional</a>和<a href="http://www.heaventools.com/" target="_blank" rel="noopener">PE Explorer</a></p>
<p>PE文件头可获得导入函数、导出函数、时间戳、分节、子系统（指示程序是一个命令行还是图形界面应用程序）、资源等信息</p>
<h2 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>利用一套相对简单的工具，我们就可以对恶意代码进行静态分析，来获得一些它功能上的观察。</p>
<h1 id="Chapter2-虚拟机中分析恶意代码"><a href="#Chapter2-虚拟机中分析恶意代码" class="headerlink" title="Chapter2 虚拟机中分析恶意代码"></a>Chapter2 虚拟机中分析恶意代码</h1><p>MALWARE ANALYSIS IN VIRTUAL MACHINES<br>动态分析恶意代码之前必须建立一个安全环境，以预防迅速蔓延至网络中的其他主机，规避不必要的风险。</p>
<p>想安全地研究恶意代码，需要专用的物理主机或是虚拟机。并进行网络隔离防止传播蔓延。物理机上分析恶意代码缺点就是缺乏互联网连接和恶意代码难以移除。优势在于恶意代码会进行反虚拟机行为。但由于虚拟机的简单，便捷，大多数动态分析选择虚拟机。</p>
<p>虚拟接采用主机模式（host-only），创建多个虚拟机进行网络连接。善用虚拟机的快照功能，他很方便。</p>
<h1 id="Chapter3-动态分析基础技术"><a href="#Chapter3-动态分析基础技术" class="headerlink" title="Chapter3 动态分析基础技术"></a>Chapter3 动态分析基础技术</h1><p>动态分析技术是在运行恶意代码之后进行检查的过程，在静态分析基础技术进入到死胡同之后。包括在恶意代码运行时刻进行监控，以及在恶意代码运行之后检查系统情况。</p>
<p>Advantages:</p>
<ul>
<li>Observe the malware’s true functionality</li>
<li>Identify malware functionality</li>
</ul>
<p>Disadvantages:</p>
<ul>
<li>Put our network and system at risk</li>
<li>Not all code paths may execute when a piece of malware is run<br>(such as command-line malware that requires arguments)</li>
</ul>
<p>此时，最好的办法是利用高级的动态或静态分析技术。</p>
<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p>Sandbox is a security mechanism for running untrusted programs in a safe environment without fear of harming“real” .</p>
<p>沙箱包括一个虚拟环境，通过某种方式模拟网络服务，确保被测试的样本能被正常执行。</p>
<p>Using a Malware Sandbox:</p>
<ul>
<li><strong>Norman Sandbox</strong></li>
<li><strong>GFI Sandbox</strong></li>
<li>Anubis</li>
<li>Joe Sandbox</li>
<li>ThreatExpert</li>
<li>Birblaze</li>
<li>Comodo</li>
</ul>
<p>Free Online Automated Malware Analysis:</p>
<ul>
<li><a href="https://www.hybrid-analysis.com/" target="_blank" rel="noopener"><strong>Hybrid Analysis</strong></a></li>
<li><a href="http://sandbox.pikker.ee/" target="_blank" rel="noopener"><strong>sandbox.pikker.ee</strong></a></li>
<li><a href="http://akana.mobiseclab.org/" target="_blank" rel="noopener">Akana</a>(Android Fils)</li>
<li><a href="http://detux.org/" target="_blank" rel="noopener">DetuxSandbox</a>(Linux binaries)</li>
<li><a href="https://www.secondwrite.com/product/free-subscription/" target="_blank" rel="noopener">SecondWrite</a>(free version)</li>
<li><a href="http://www.threatexpert.com/submit.aspx" target="_blank" rel="noopener">ThreatExpert</a></li>
</ul>
<p>Sandbox Drawbacks:</p>
<ul>
<li>简单执行可执行文件，不能带有命令行选项。</li>
<li>需要等待一条控制指令的后门程序无法被启动和分析</li>
<li>无法记录所有事情（maybe 如设置一天后执行恶意行为的恶意代码）</li>
<li>一些恶意代码会检测虚拟机从而停止运行或是表现异常</li>
<li>一些恶意代码需要系统上拥有特定的注册表项或文件才能执行，which not be found in sandbox</li>
<li>如果恶意代码是一个DLL，则一些导出函数不会被恰当的调用（invoked properly），DLL不想exe那样容易运行</li>
<li>沙箱的操作系统可能对恶意代码来说不正确。</li>
<li>沙箱只能汇报恶意代码的基本功能，而不会告诉它做了什么，需要自己总结。</li>
</ul>
<h2 id="运行恶意代码"><a href="#运行恶意代码" class="headerlink" title="运行恶意代码"></a>运行恶意代码</h2><blockquote>
<p>所有的Windows版本中都包含rundll32.exe程序来提供运行DLL的平台</p>
</blockquote>
<p>Launch malicious DLLs<br><code>C:\&gt;rundll32.exe DLLname, Export arguments
C:\&gt;rundll32.exe xyzzy.dll, #5</code><br><em>The Export value must be a function name or ordinalselected from the exported function table in the DLL.</em></p>
<p>还可修改PE头中，将IMAGE_FILE_HEADER特征域里擦除IMAGE_FILE_DLL (0x2000) 标记。</p>
<p>DLL形态的恶意代码也有可能需要被安装城一个服务。</p>
<p><strong>net start</strong> 命令可以启动windows指定服务<br>Windows服务的注册表项位于HKLM\SYSTEM\CurrentControlSet\Services</p>
<h2 id="进程监视器"><a href="#进程监视器" class="headerlink" title="进程监视器"></a>进程监视器</h2><p><a href="https://web.archive.org/web/20110101122655/http:/technet.microsoft.com/en-us/sysinternals/bb896645" target="_blank" rel="noopener">procmon</a></p>
<p>An advanced monitoring tool for Windows that provides a way to  monitor certain registry, file system, network, process, and thread activity.<br>它结合了文件监视器FileMon和注册表监视器RegMon的功能</p>
<p>它一旦运行起来就会监控所有能捕捉的系统调用，而且他是用内存来记录事件，所以可能会耗尽内存而使虚拟机崩溃。</p>
<p>善用procmon的过滤功能：</p>
<ul>
<li>过滤出运行的恶意代码</li>
<li>过滤特定的系统调用如RegSetValue, CreateFile, WriteFile, or other suspicious or destructive calls.</li>
<li>常用过滤 Process Name, Operation, and Detail</li>
</ul>
<p>过滤器仅仅用于显示过滤，所有信息都会被记录。</p>
<h2 id="进程浏览器"><a href="#进程浏览器" class="headerlink" title="进程浏览器"></a>进程浏览器</h2><p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/process-explorer" target="_blank" rel="noopener">Process Explorer</a>, free from Microsoft, is an extremely powerful task manager that should be running when you are performing dynamic analysis.</p>
<ul>
<li>Services are highlighted in pink, </li>
<li>processes in blue, </li>
<li>new processes in green, and </li>
<li>terminated processes in red. </li>
<li>Green and red highlights are temporary, and are removed after the process has started or terminated</li>
</ul>
<p>Process Explorer shows five columns: Process (the process name), PID (the process identifier), CPU (CPU usage), Description, and Company Name.<br><em>–The view updates every second.</em> </p>
<p>使用verify可以检验该镜像文件是否具有微软的签名认证，但攻击者使用进程替换技术则该功能无效。</p>
<p>比较字符串在内存中和在磁盘上差异可以识别进程替换技术。</p>
<p>进程浏览器还可以用来分析恶意文档。</p>
<h2 id="用Regshot比较注册表快照"><a href="#用Regshot比较注册表快照" class="headerlink" title="用Regshot比较注册表快照"></a>用Regshot比较注册表快照</h2><p><a href="https://sourceforge.net/projects/regshot/" target="_blank" rel="noopener">Regshot</a>是一个开源的注册表比较工具，他可以让我们比较两个注册表的快照，并发现差异。</p>
<h2 id="模拟网络"><a href="#模拟网络" class="headerlink" title="模拟网络"></a>模拟网络</h2><p>Malware often beacons out and eventually communicates with a command-and-control server</p>
<p>Network indicators：</p>
<ul>
<li>DNS names</li>
<li>IP address </li>
<li>packet signatures</li>
</ul>
<p><a href="https://www.aldeid.com/wiki/Mandiant-ApateDNS" target="_blank" rel="noopener">ApateDNS</a>一款来自Mandiant公司的免费软件，用来查看恶意代码发出的DNS请求最快速的方式。<br>needs <a href="https://www.microsoft.com/en-us/download/details.aspx?id=17851" target="_blank" rel="noopener">.NetFramework 4.0/3.5</a></p>
<p>使用Netcat进行监听<br>使用wireshark进行数据包监听<br>使用<a href="http://www.inetsim.org/packages.html" target="_blank" rel="noopener">INetSim</a>是一款基于Linux模拟常见网络服务的免费软件</p>
<h2 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h2><p>恶意代码的动态分析基础技术能帮助和确认基本的静态分析结果。<br>但也有不足，我们需要逆向分析协议，下一步就是在二进制指令级别进行反汇编与解剖的静态分析高级技术。</p>
<h1 id="Chapter4-A-Crash-Course-in-X86-Disassembly"><a href="#Chapter4-A-Crash-Course-in-X86-Disassembly" class="headerlink" title="Chapter4 A Crash Course in X86 Disassembly"></a>Chapter4 A Crash Course in X86 Disassembly</h1><p><img src="https://raw.githubusercontent.com/flame7wq/MarkdownPic/master/Image.png" alt="img.png"></p>
<h2 id="抽象层次"><a href="#抽象层次" class="headerlink" title="抽象层次"></a>抽象层次</h2><p>通常，计算机系统被描述为以下六个抽象层次，越高的抽象层次越接近顶端，一个抽象层次越低，他的跨系统移植性就越差。</p>
<ol>
<li>硬件 Hardware<ul>
<li>唯一的物理层，由电子电路组成，实现XOR门、AND门、NOT门和OR门等逻辑运算器的复杂组合，aka. 数字逻辑。</li>
</ul>
</li>
<li>微指令 Microcode 又称固件（firmware）<ul>
<li>微指令只能在它设计的特定电路上执行。当分析恶意代码时，我们不关心微指令，因为他们是为特定的计算机硬件设计的。</li>
</ul>
</li>
<li>机器码 Machine code <ul>
<li>机器码层由操作码（opcode）组成，操作码是一些十六进制形式的数字。机器码一般由多条微指令实现，这样底层能实际执行代码了。而机器码本身又是有高级语言编写的计算机程序编译而来。</li>
</ul>
</li>
<li>低级语言 Low-level languages <ul>
<li>主要是汇编语言，我们使用反汇编器来生成低级语言的文本。<blockquote>
<p>在获取不到高级语言源码时，汇编语言是从机器码中能可信并保持一致性地还原得到的最高一层语言。</p>
</blockquote>
</li>
</ul>
</li>
<li>高级语言 High-level languages <ul>
<li>大部分程序员使用高级语言。高级语言对机器层做了很强的抽象，如C、C++，他们被编译器编译成机器码。</li>
</ul>
</li>
<li>解释型语言 Interpreted languages <ul>
<li>解释语言位于最高层，如C#、Perl、.NET、Java等。这一层的语言不会被翻译成机器码，而是字节码Bytecode。</li>
<li>字节码是特定于该语言的一种中间表示，它在解释器中执行。</li>
<li>解释器（interpreter）是一个在运行时将字节码实时翻译为可执行机器码的程序。相比于传统被编译的代码，解释器提供了一种自动的抽象层次，因为他可以独立于操作系统，自己处理错误和管理内存</li>
</ul>
</li>
</ol>
<h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p>恶意代码存储在磁盘上时，通常是机器码层的二进制形式。我们将而已代码二进制文件作为输入经过反汇编器形成汇编语言代码。<br>汇编语言实际上是一类语言的统称，每种汇编语言的方言，都是用来对一类微处理器家族编程的，例如，X86、X64、SPARC、PowerPC、MIPS、ARM等。目前，x86是PC上最流行的体系结构。<br>X86又称Intel IA-32，是大部分32位PC使用的体系结构。正因如此，大部分恶意代码时x86编译的。</p>
<h2 id="x86体系结构"><a href="#x86体系结构" class="headerlink" title="x86体系结构"></a>x86体系结构</h2><p>大部分现代计算机体系结构在内部实现上遵循冯诺依曼结构，该结构包括3种硬件组件：</p>
<ul>
<li>CPU，执行代码</li>
<li>内存（RAM），存储数据和代码</li>
<li>输入输出系统（I/O），为硬件、键盘、显示器等设备提供接口。</li>
</ul>
<p><strong>内存</strong><br>一个程序的内存可以分为以下四个主要的节</p>
<ol>
<li>Data <ul>
<li>This term can be used to refer to a specific section of memory called the data section, which contains values that are put in place when a program is initially loaded.<br>These values are sometimes called static values because they may not change while the program is running, or they may be called global values because they are available to any part of the program</li>
</ul>
</li>
<li>Code<ul>
<li>includes the instructions fetched by the CPU</li>
</ul>
</li>
<li>Heap<ul>
<li>used for dynamic memory during program execution, to create (allocate) new values and eliminate (free) values that the program no longer needs. </li>
<li>The heap is referred to as dynamic memory because its contents can change frequently while the program is running.</li>
</ul>
</li>
<li>Stack<ul>
<li>used for local variables and parameters for functions, and to help control program flow.</li>
</ul>
</li>
</ol>
<p><strong>指令</strong><br>指令instructions是汇编程序的构成块。x86中，指令由一个助记符以及零个或多个操作数组成。<br><code>mov ecx, 0x42 →B9 42 00 00 00</code></p>
<p><strong>操作码和字节序</strong><br>反汇编器将操作码翻译为人类易读的指令，如0xB9对应 mov ecx.</p>
<p>数据的字节序（Endianness）是指在一个大数据项中，最高位（大端，big-endian）还是最低位（小端-little-endian）被排在第一位（即排在最低的地址上）</p>
<ul>
<li>x86使用小端字节序。</li>
<li>网络数据使用大端字节序。（所以恶意代码在网络通信时有必要改变字节序）</li>
</ul>
<p><strong>操作数</strong></p>
<ul>
<li>Immediate operands<br>fixed values, such as 0x42</li>
<li>Register operands<br>mov eax, ecx</li>
<li>Memory Addresses -mov [esp], eax<br>denoted by a value, register, or equation between brackets, [ecx]</li>
</ul>
<p><strong>寄存器</strong></p>
<ul>
<li>General Registers(32 bits): Used by the CPU during execution</li>
<li>Segment Registers: Used to track sections of memory</li>
<li>Status Flags: Used to make decisions</li>
<li>Instruction Pointer (eip): Used to keep track of the next<br>所有通用寄存器都是32bits，可以以32位或16位甚至是8位引用。</li>
</ul>
<p>notes：</p>
<ol>
<li>通用寄存器中乘法和除法指令只能使用 EAX 和 EDX</li>
<li>some conventions： EAX经常存储一个函数调用的返回值</li>
<li>标志寄存器中每一位都是一个标志，这些值控制CPU的运算，或者给出某些CPU运算的值。<br>对于恶意代码分析师来说重要的标志如下：<ul>
<li>ZF 零标志 当运算结果为0时，ZF被置位（值为1）</li>
<li>CF 进位标志 当运算结果产生进位或借位，其值为1</li>
<li>SF 符号标志 当运算结果为负，值为1</li>
<li>TF 追踪标志 当追踪标志TF被置为1时，CPU进入单步执行方式，即x86处理器每次只执行一条指令</li>
</ul>
</li>
<li>指令指针 EIP<ul>
<li>EIP又称指令指针或程序计数器，唯一作用是告诉处理器接下来要做什么<blockquote>
<p>控制了EIP，也就控制了CPU将要执行什么，这也是攻击者试图通过漏洞利用获得对EIP的控制。通常，攻击者先要使攻击代码进入内存，然后改变EIP使其指向那段代码，使其攻击系统。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<p><strong>简单指令</strong></p>
<ol>
<li>mov 将数据移动到寄存器或内存<ul>
<li>mov destination，source<br>Intel syntax： lists the destination operand first</li>
</ul>
</li>
<li>lea -Load Effective Address 取地址</li>
<li>add destination, value</li>
<li>sub destination, value<ul>
<li>sub会修改 ZF 和 CF</li>
</ul>
</li>
<li>inc/dec eax 寄存器+1或-1</li>
<li>mul/div value<ul>
<li>对eax乘或除value<br>所以eax在运算之前就得赋值好</li>
<li>乘法结果分开存储在edx：eax中</li>
<li>除法被除数存在edx：eax中，商存在eax中，余数存在edx中</li>
</ul>
</li>
<li>imul/idiv 为6的有符号版本</li>
<li>逻辑运算符or/and/xor destination, value</li>
<li>寄存器的移位运算符 shr/shl destination, count</li>
<li>循环移位 ror/rol<blockquote>
<p>在分析恶意代码时，一个函数中只有逻辑和移位指令，且反复出现，很可能遇到一个加密或者压缩函数。<br>不要陷进去，将它做好标记继续后面的分析。</p>
</blockquote>
</li>
<li>NOP xchg eax, eax 的伪名字，即空指令什么也不做（0x90）</li>
</ol>
<p><strong>条件指令</strong></p>
<ol>
<li>test value，value<br>test和and指令功能一样，但它不会修改使用的操作数，只设置标志位，<br>Only sets the ZF (Zero Flag): test if eax is zero.</li>
<li>cmp des, src<br>cmp指令和sub指令功能一样，与test一样也不会影响操作数<br>其结果使CF和ZF会变化<br>dst &lt; src zf=0 cf=1</li>
</ol>
<p><strong>分支指令</strong><br>最常见的分支指令是跳转指令 jmp location</p>
<ol>
<li>jmp为无条件跳转</li>
<li>条件跳转用标志位来决定是跳转还是执行下一条指令<ul>
<li>JZ、JNZ</li>
<li>JE、JNE 通常在cmp后，源操作数与目的操作数相等则跳转</li>
<li>……</li>
</ul>
</li>
</ol>
<p><strong>重复指令</strong><br>重复指令是一组操作缓冲区的指令，数据缓冲区通常是字节数组的形式，也可以是单字或双字<br>movsx, cmpsx, stosx, scasx<br>–x = b, w, or d for byte, word, and double word</p>
<p>rep指令终止条件与ECX是否为0有关</p>
<p><strong>栈</strong><br>A stack is a last in, first out (LIFO) structure.</p>
<p>x86对栈有内建支持，使用ESP和EBP。<br>与栈有关的指令有push、pop、call、leave、enter和ret</p>
<p>在内存中，栈被分配为自顶向下的，即向下生长，最高的地址最先被使用。</p>
<p>栈只能用于短期存储，经常保存局部变量、参数和返回地址。其主要用途是管理函数调用之间的数据交换。</p>
<blockquote>
<p>局部变量从 ebp-4 开始，<br>参数： ebp+8<br>eip： ebp+4<br>ebp：原来的栈底（调用前的ebp）</p>
</blockquote>
<p>调用约定 <strong>cdecl</strong><br>The cdecl (which stands for C declaration) is a calling convention that originates from the C programming languageand is used by many C compilers for the x86 architecture.<br>函数返回结果存在eax中，浮点数值存在ST0 x87 寄存器<br>ST0~ST7在调用新函数之前必须为空</p>
<p>函数实现最常用的流程：</p>
<ol>
<li>使用push将参数压入栈中</li>
<li>使用call memory_location来调用函数。<ul>
<li>eip压栈</li>
<li>函数开始执行时，eip的值为memory_location</li>
</ul>
</li>
<li>分配局部变量空间，ebp压栈</li>
<li>函数开始工作</li>
<li>恢复堆栈。调整esp来释放局部变量，恢复ebp。leave指令可以作结，它的功能是使esp=ebp，然后从栈中弹出ebp</li>
<li>函数调用ret指令返回，这个指令会从栈中弹出返回地址给EIP，因此程序会从原来调用的地方继续执行。</li>
<li>调整栈，移出之前压入的参数。</li>
</ol>
<p>notes：</p>
<blockquote>
<p>局部变量从 ebp-4 开始，<br>参数： ebp+8<br>eip： ebp+4<br>ebp：原来的栈底（调用前的ebp）</p>
</blockquote>
<h1 id="Chapter5-IDA-Pro"><a href="#Chapter5-IDA-Pro" class="headerlink" title="Chapter5 IDA Pro"></a>Chapter5 IDA Pro</h1><p>借IDA pro这本书</p>
<p>当加载一个文件到IDA Pro中时，IDA Pro像操作系统加载器一样将文件映射到内存中，</p>
<h2 id="IDA-Pro接口"><a href="#IDA-Pro接口" class="headerlink" title="IDA Pro接口"></a>IDA Pro接口</h2><p>反汇编窗口有图形模式和文本模式，可以按<strong>空格键</strong>进行切换。</p>
<p>图形模式中，箭头的颜色和方向帮助我们在分析时显示程序的流程：</p>
<ul>
<li>红色表示一个条件跳转没有被采用</li>
<li>绿色表示这个条件跳转被采用</li>
<li>蓝色表示一个无条件跳转被采用</li>
</ul>
<p>箭头的方向显示了程序的流程，向上表示一个循环条件。</p>
<p>文本模式显示了内存地址和节名，在这个节中操作码会驻留在内存中<br>文本模式下实现标记了无条件跳转，虚线标记了条件跳转，朝上的箭头表示一个循环。</p>
<p><strong>对分析有用的窗口</strong><br>这些窗口还提供了交叉引用的特性，这些特性在定位有意义代码时十分有用。</p>
<ul>
<li><p>函数窗口</p>
<ul>
<li>F-far function</li>
<li>L-library function</li>
<li>S-static function</li>
<li>R-function returns to the caller</li>
<li>B-BP based frame</li>
</ul>
</li>
<li><p>名字窗口</p>
</li>
<li><p>字符串窗口</p>
</li>
<li><p>导入表窗口</p>
</li>
<li><p>导出表窗口</p>
</li>
<li><p>结构窗口</p>
</li>
</ul>
<p>windows-&gt;Reset Desktop 返回默认视图</p>
<p><strong>导航栏</strong><br>我们应该在深蓝色区域执行恶意代码分析。</p>
<ul>
<li>浅蓝色是被FLIRT识别的库代码</li>
<li>红色是编译器生成的代码</li>
<li>深蓝色是用户编写的代码</li>
<li>灰色为已定义的数据</li>
<li>棕色为未定义的数据</li>
</ul>
<p>在反汇编窗口按G键可跳转至任意虚拟内存地址</p>
<h1 id="Chapter6-Recognizing-C-Code-Constructs-in-Assembly"><a href="#Chapter6-Recognizing-C-Code-Constructs-in-Assembly" class="headerlink" title="Chapter6 Recognizing C Code Constructs in Assembly"></a>Chapter6 Recognizing C Code Constructs in Assembly</h1><p><a href="https://www.aldeid.com/wiki/X86-assembly/Instructions" target="_blank" rel="noopener">x86汇编指令</a></p>
<p>由于过程太过冗余，指令繁多，所以只有当我们需要时才会去关注单条指令，需要以组为单位来分析指令</p>
<p>编译器的版本和设置能影响一个特定结构在反汇编代码中的表现。</p>
<h2 id="全局与局部变量"><a href="#全局与局部变量" class="headerlink" title="全局与局部变量"></a>全局与局部变量</h2><p>全局变量可以被一个程序中的任意函数访问和使用。局部变量只能在它被定义的函数中访问。</p>
<p>在反汇编代码中，全局变量通过内存地址引用，而局部变量通过栈地址引用。</p>
<h2 id="反汇编算术操作"><a href="#反汇编算术操作" class="headerlink" title="反汇编算术操作"></a>反汇编算术操作</h2><blockquote>
<p>栈的分配与清空<br>push ebp<br>mov ebp，esp<br>sub esp，num<br>……（参数ebp+8，局部变量从ebp-4开始）<br>xor eax，eax<br>mov esp，ebp<br>pop ebp<br>retn</p>
</blockquote>
<p>除法被除数存储在 <strong>EDX:EAX</strong> 中，商保存在 EAX 中，余数保存在 EDX 中</p>
<h2 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h2><p>对于一个if语句，必定有一个条件跳转，但不是所有条件跳转都对应if语句。</p>
<p>如if语句对应一个条件跳转 jnz ，跳转的决定是基于一个比较 cmp 语句来做的。</p>
<p><strong>识别嵌套if语句</strong></p>
<h2 id="循环LOOPS"><a href="#循环LOOPS" class="headerlink" title="循环LOOPS"></a>循环LOOPS</h2><p><strong>for循环</strong><br>for循环总是有4个组件：初始化、比较、执行指令，以及递增或递减<br>存在 无条件跳转jmp往回跳<br><strong>while循环</strong><br>while循环频繁地被恶意代码作者使用。</p>
<h2 id="函数调用约定"><a href="#函数调用约定" class="headerlink" title="函数调用约定"></a>函数调用约定</h2><p>调用约定决定了函数调用发生的方式，包括参数被放在栈上或寄存器上的次序，以及是由调用者还是被调用者负责函数执行完成时清理栈。</p>
<blockquote>
<p>同样的约定在编译器之间也有实现上的差异。</p>
</blockquote>
<ol>
<li>cdecl，参数从右到左按序压入栈，调用者清理栈，且返回值存在EAX中。<blockquote>
<p>push c<br>push b<br>push a<br>call test<br>add esp,12<br>mov ret,eax</p>
</blockquote>
</li>
<li>stdcall，被调函数清理栈，其他同cdecl<br> stdcall是Windows API的标准调用约定。任何调用这些API的代码都不需要清理栈，因为清理栈的责任是由实现API函数代码的DLL程序所承担的。    </li>
<li>fastcall，fastcall通常是前两个参数被传进寄存器，剩下的从参数从右到左压入栈，所以参数少时，fastcall效率更高。</li>
</ol>
<h2 id="分析Switch语句"><a href="#分析Switch语句" class="headerlink" title="分析Switch语句"></a>分析Switch语句</h2><p>switch语句被程序员（和恶意代码作者）用来做一个居于字符或整数的决策。如后门通常使用单一的字节值从一系列动作中选一个。<br>switch语句通常以两种方式被编译：</p>
<ol>
<li>if样式</li>
<li>跳转表（出现在庞大连续的switch语句中）</li>
</ol>
<h2 id="反汇编数组"><a href="#反汇编数组" class="headerlink" title="反汇编数组"></a>反汇编数组</h2><p>汇编代码中，数组是通过使用一个基地址作为起始点来进行访问的。</p>
<h2 id="结构体Struct"><a href="#结构体Struct" class="headerlink" title="结构体Struct"></a>结构体Struct</h2><p>结构体与数组类似，但是它们包括不同类型的元素。通常被恶意代码作者用来组织信息。有时使用结构体比独立维护很多不同类型的变量更简单。<br>结构体通过一个作为起始指针的基地址来访问。</p>
<h2 id="分析链表遍历-Linked-List-Traversal"><a href="#分析链表遍历-Linked-List-Traversal" class="headerlink" title="分析链表遍历 Linked List Traversal"></a>分析链表遍历 Linked List Traversal</h2><h1 id="Chapter7-Analyzing-Malicious-Windows-Programs"><a href="#Chapter7-Analyzing-Malicious-Windows-Programs" class="headerlink" title="Chapter7 Analyzing Malicious Windows Programs"></a>Chapter7 Analyzing Malicious Windows Programs</h1><p>多数恶意代码以Windows平台为目标，并且与操作系统紧密交互。<br>对基本的Windows编程概念的深刻理解会有助于：</p>
<ol>
<li>识别出恶意代码在主机上的感染迹象</li>
<li>跟踪恶意代码的执行</li>
<li>分析出恶意代码的目的</li>
</ol>
<p>恶意代码通常结构很差，并且趋向于执行预期之外的动作。</p>
<h2 id="Windows-API"><a href="#Windows-API" class="headerlink" title="Windows API"></a>Windows API</h2><p>Windows API 是一个广泛的功能集合，管理着恶意代码与微软程序库之间的交互方式。<br>Windows API 使用特定术语，名字，以及约定。</p>
<p><strong>类型和匈牙利表达法</strong><br>多数API使用它自己的名字，来表示C语言类型。如DWORD和WORD分别表示32位和16位无符号整数。标准C类型int、short，以及unsigned int通常并不使用。</p>
<p>Windows总体使用匈牙利表达法，使用前缀命名模式。如参数为dwSize，dw即值32位无符号整数。该表达法会使识别变量类型和解析代码更容易，但也能变得笨重（unwieldy）</p>
<p>常见类型前缀：</p>
<ul>
<li>WORD（w）</li>
<li>DWORD（dw） </li>
<li>Handles（H）</li>
<li>Long Pointer（L）</li>
<li>Callback</li>
</ul>
<p><strong>句柄</strong></p>
<ul>
<li>句柄是在OS中被打开或被创建的项，比如一个窗口、进程、模块、菜单、文件，etc<br>如，CreateWindowEx函数时一个句柄的简单例子，它返回一个HWND，这是一个窗口句柄，当调用DestroyWindow函数时，需要调用这个句柄。</li>
<li>句柄在引用一个对象时很像指针，但与指针不同的是，句柄不能被用来进行数学操作，并且他们不总是表示对象地址。</li>
<li>对句柄唯一能做的是保存它，并在后续函数调用中使用它来引用同一个对象。</li>
</ul>
<p><strong>文件系统函数</strong><br>恶意代码与系统交互的一个最常用的方式就是创建或修改文件，而且独特文件名或修改为既有文件名是明显的基于主机的感染迹象host-based indicators。<br>文件活动可以提示恶意代码在做什么。</p>
<p>微软提供多个函数来访问文件系统</p>
<ol>
<li>CreateFile<ul>
<li>create and open files</li>
<li>The parameter dwCreationDisposition controls whether to create a new file or open an existing one.</li>
</ul>
</li>
<li>ReadFile and WriteFile<ul>
<li>reading and writing to files.</li>
<li>Both operate on files as a stream.都将文件作为流来操作</li>
</ul>
</li>
<li>CreateFileMapping and MapViewOfFile<ul>
<li>文件映射经常被恶意代码作者使用，因为它允许讲一个文件加载到内存中，以便更加轻易地进行操作。</li>
<li>前者负责从磁盘上加载一个文件到内存中。后者返回一个指向映射的基地址指针，他可以访问内存中的文件。这个特性在解析一个文件格式时极其顺手，因为可以简单跳转到不同内存地址</li>
<li>在获得一个文件的映射后，恶意代码可以解析PE头，并对内存中的文件进行所有需要的修改，因此使PE文件就像被操作系统加载器加载一样执行起来。</li>
</ul>
</li>
</ol>
<p><strong>特殊文件</strong><br>Windows中有一些特殊的文件类型，无法通过盘符与文件夹进行访问。<br>恶意代码经常使用特殊文件。</p>
<ol>
<li>共享文件Shared Files<br>共享文件是以\\serverName\share或\\?\\serverNamelshare开头命名的特殊文件。他们用来访问保存在共享目录中的目录或文件。\\?\\前缀告诉操作系统禁用所有的字符串解析，并允许访问长文件名。</li>
<li>通过名字空间访问的文件</li>
<li>备用数据流ADS<br>Alternate Data Streams特性允许附加数据被添加到一个已存在的NTFS文件中，相当于添加一个文件到另一个文件中。额外数据在列一个目录时不会被显示出来，并且当显示文件内容时也不显示；<em>而只有访问流时，他才是可见的it’s visible only when you access the strean</em></li>
</ol>
<p>恶意代码作者喜欢ADS，因为它能用来影藏数据。</p>
<h2 id="Windows注册表-Registry"><a href="#Windows注册表-Registry" class="headerlink" title="Windows注册表 Registry"></a>Windows注册表 Registry</h2><p>Windows注册表被用来保存操作系统与程序的配置信息，比如设置和选项。</p>
<ul>
<li>和文件系统一样，它是基于主机的感染迹象的很好来源，并且能揭示出恶意代码功能的有用信息。</li>
<li>早期的版本使用.ini文件来配置信息。</li>
<li>几乎所有的Windows配置信息都保存在注册表中，包括networking, driver, 启动项startup, user account, and other information</li>
</ul>
<p>恶意代码经常使用注册表来持久驻留或者存储配置数据。恶意代码添加到注册表中，这使它在计算机引导时能够自启动。</p>
<p>Important Registry Terms</p>
<ul>
<li><strong>Root key根键</strong> The registry is divided into five top-level sections called root keys.5个顶层节<br>  – Sometimes, the terms HKEY and hive are also used.<br>  – Each of the root keys has a particular purpose.</li>
<li><strong>Subkey</strong> A subkey is like a subfolder within a folder.</li>
<li><strong>Key</strong> A key is a folder in the registry that can contain additional folders or values.<br>  – The root keys and subkeys are both keys.</li>
<li><strong>Value entry</strong> A value entry is an ordered pair with a name and value.</li>
<li><strong>Value or data</strong> The value or data is the data stored in a registry entry（注册表项）.</li>
</ul>
<p>Five Root Keys</p>
<ul>
<li><strong>HKEY_LOCAL_MACHINE (HKLM)</strong><br>  – Stores settings that are global to the local machine 本地机器的全局设置</li>
<li>HKEY_CURRENT_USER (HKCU)<br>  – Stores settings specific to the current user 当前用户的特定设置</li>
<li>HKEY_CLASSES_ROOT<br>  – Stores information defining types 定义的类型信息</li>
<li>HKEY_CURRENT_CONFIG<br>  – Stores settings about the current hardware configuration, specifically differences between the current and the standard configuration 当前硬件的配置设置</li>
<li><strong>HKEY_USERS</strong><br>  – Defines settings for the default user, new users, and current users所有用户的配置</li>
</ul>
<p>两个最常用的的根键时HKLM和HKCU<br>一个常用的子键:<strong>HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run</strong>,包含了当用户登录时被自动启动的可执行程序，向run子键中写入项，经常被恶意代码来自启动</p>
<p><a href="https://docs.microsoft.com/en-us/sysinternals/downloads/autoruns" target="_blank" rel="noopener">Autoruns</a>列举了在操作系统启动时会自动启动运行的代码。</p>
<p><strong>常用注册表函数</strong><br>注册表函数属于API，常用的有：</p>
<ul>
<li>RegOpenKeyEx 打开一个注册表进行编辑和查询，但大多会先用到RegOpenKeyEx</li>
<li>RegSetValueEx 添加一个新值到注册表，并设置它的数值</li>
<li>RegGetValue 返回注册表中一个值的项</li>
</ul>
<p><strong>使用.reg文件的注册表脚本</strong><br>用.reg作为扩展的文件包含一个人类可读的注册表数据。当用户双击一个.reg文件时，他会自动地通过合并文件包含的信息到注册表中，来修改注册表–几乎像一个修改注册表的脚本一样。</p>
<blockquote>
<p>Windows Registry Editor Version 5.00</p>
<p>[HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run]<br>“MaliciousValue”=”C:\windows\evil.exe”</p>
</blockquote>
<h2 id="网络API"><a href="#网络API" class="headerlink" title="网络API"></a>网络API</h2><p><strong>Berkeley compatible sockets</strong><br>在Windows的网络选项中，恶意代码最普遍使用的是伯克利兼容套接字，在Windows上由Winsock实现，主要在ws2_32.dll<br>Of these, the socket, connect, bind, listen, accept, send, and recv functions are the most common.</p>
<blockquote>
<p>Notes:<br>WSAStartup函数必须在其他网络函数之前被调用，以便为这些网络库分配资源。<br>在调试代码查找网络入口时，在WSAStartup函数中设置一个断点非常有用，因为网络入口应该跟在后面不远的地方。</p>
</blockquote>
<p><strong>The WinINet API</strong><br>它是比Winsock更高一级的windows API，函数保存在 Wininet.dll中。<br>The WinINet API implements protocols, such as HTTP and FTP, at the application layer.</p>
<ul>
<li><em>InternetOpen</em> is used to initialize a connection to the Internet.</li>
<li><em>InternetOpenUrl</em> is used to connect to a URL (which can be an HTTP page or an FTP resource).</li>
<li><em>InternetReadFile</em> works much like the ReadFile function, allowing the program to read the data from a file downloaded from the Internet.</li>
</ul>
<h2 id="跟踪恶意代码的运行"><a href="#跟踪恶意代码的运行" class="headerlink" title="跟踪恶意代码的运行"></a>跟踪恶意代码的运行</h2><p>弄清恶意代码如何调用其他代码运行很重要。最常见的方式就是通过使用DLL程序。<br><strong>DLLS</strong></p>
<ul>
<li>All processes share loaded DLLs<ul>
<li>Saves space, only loaded into memory once<ul>
<li>Must map into your own virtual address space (LoadLibrary)</li>
</ul>
</li>
<li>Changes only affect your processes address space</li>
<li>Another major advantage to using DLLs is that when distributing an executable</li>
<li>You can use DLLs that are known to be on the host Windows system without needing to redistribute them. </li>
</ul>
</li>
<li>Exports functions for use by processes</li>
<li>DllMain is automatically called when loaded</li>
<li>Some API: LoadLibrary, GetProcAddress</li>
</ul>
<p>How Malware Authors Use DLLs？恶意代码作者发现将恶意代码保存到一个DLL文件比exe文件更加有利。有些恶意代码会附加到其他进程，但每一个进程只能包含一个.exe文件。因此恶意代码有时使用DLL程序来将它加载到另一个进程中。</p>
<ol>
<li>By using Windows DLLs<ul>
<li>The way that a malicious program uses the Windows DLLs often offers tremendous insight to the malware analyst.</li>
</ul>
</li>
<li>By using third-party DLLs<ul>
<li>When you see malware that imports functions from a third-party DLL, you can infer that it is interacting with that program to accomplish its goals.</li>
</ul>
</li>
</ol>
<p><strong>Basic DLL Structure</strong></p>
<ul>
<li>DLL files look almost exactly like .exe files.<ul>
<li>DLLs use the PE file format, and <em>only a single flag indicates</em> that the file is a DLL and not an .exe.</li>
<li>DLLs often have more exports and generally fewer imports.</li>
<li>Other than that, <em>there’s no real difference between a DLL and an .exe.</em></li>
</ul>
</li>
<li>The main DLL function is DllMain.<ul>
<li>It has no label and is not an export in the DLL, but it is specified in the PE header as the file’s entry point.</li>
</ul>
</li>
<li>DllMain is called to notify the DLL whenever<ul>
<li>A process loads or unloads the library, creates a new thread, or finishes an existing thread.</li>
<li>This notification allows the DLL to <em>manage any per-process or perthread resources.</em></li>
</ul>
</li>
</ul>
<p><strong>进程</strong></p>
<ul>
<li>Windows使用进程作为管理资源的容器。</li>
<li>每个进程有自己的虚拟内存空间、线程、管理信息</li>
<li>传统上，恶意代码包括他自己的独立进程，但更新型的恶意代码则普遍将自身代码作为其他进程的一部分执行。</li>
<li>Some API: CreateProcess, CreateProcessAsUser, EnumProcesses</li>
</ul>
<p>Remote Shell by CreateProcess</p>
<ul>
<li>Malware commonly uses CreateProcess to <em>create a simple remote shell with just a single function call</em>.</li>
<li>One of the parameters to the CreateProcess function, the</li>
<li>STARTUPINFO* struct, includes a handle to the standard input, standard output, and standard error streams for a process.</li>
<li>A malicious program<ul>
<li>could set these values to a socket,</li>
<li>so that when the program writes to standard output, it is really writing to the socket,</li>
<li>thereby allowing an attacker to execute a shell remotely without running anything other than the call to CreateProcess.</li>
</ul>
</li>
</ul>
<p>Storing one program inside another in the resource section</p>
<ul>
<li>恶意代码经常在一个程序的资源节存储另一个程序，并创建一个新的进程<ul>
<li><em>PE文件的资源节中可以保存任意文件</em></li>
<li>Malware will sometimes store another executable in the resource section. </li>
</ul>
</li>
<li>当程序运行时会从PE头中提取附加的可执行文件，将它写到磁盘上，然后调用CreateProcess来运行这个程序<ul>
<li>This is also done with DLLs and other executable code.</li>
</ul>
</li>
<li>When this happens, you must open the program in the <em>Resource Hacker</em> utility and save the embedded executable file to disk in order to analyze it.</li>
</ul>
<p><strong>线程Threads</strong></p>
<ul>
<li>进程是执行代码的容器，<em>线程才是Windows操作系统真正要执行的内容</em>。<ul>
<li>Threads are independent sequences of instructions that are executed by the CPU without waiting for other threads.</li>
</ul>
</li>
<li><em>A process contains one or more threads</em>, which execute part of the code within a process.</li>
<li>Threads within a process all share the same memory space, but each has its own processor registers and stack.<ul>
<li>Scheduled and executed by the OS</li>
<li>Belong to a single process, and share its address space</li>
<li>Have their own <em>thread context and stack</em></li>
</ul>
</li>
<li>Some API: CreateThread, CreateRemoteThread</li>
</ul>
<p>线程上下文 Thread Context</p>
<ul>
<li>当一个线程运行时，有着对CPU或CPU核完全的控制，并且其他线程不能影响CPU或核的状态。</li>
<li>Keeps track of the state of a thread<ul>
<li>Necessary when there are multiple threads on a system</li>
<li>State is defined by register values</li>
</ul>
</li>
<li>Some API: GetThreadContext, SetThreadContext</li>
</ul>
<p>Use of CreateThread by Malware</p>
<ul>
<li>Malware can use <em>CreateThread to load a new malicious library</em> into a process, with CreateThread called and the address of LoadLibrary specified as the start address.<ul>
<li>The argument passed to CreateThread is the name of the library to be loaded.</li>
<li>The new DLL is loaded into memory in the process, and DllMain is called.</li>
</ul>
</li>
</ul>
<p><strong>使用互斥量的进程间协作Interprocess Coordination with Mutexes</strong></p>
<ul>
<li>One topic related to threads and processes is <em>mutexes 互斥量</em>,<ul>
<li>referred to as <em>mutants 互斥门</em> when in the kernel.</li>
</ul>
</li>
<li>Mutexes are global objects that coordinate multiple processes and threads.</li>
<li>Mutexes are mainly used to <em>control access</em> to shared resources, and are often used by malware</li>
<li><em>Only one thread can own a mutex at a time.</em><ul>
<li>The thread gains access to the mutex with a call to WaitForSingleObject, and any subsequent threads attempting to gain access to it must wait.</li>
<li>When a thread is finished using a mutex, it uses the ReleaseMutex function.</li>
</ul>
</li>
</ul>
<p><strong>服务Service</strong></p>
<ul>
<li>Another way for malware to execute additional code is by installing it as a service.</li>
<li>Windows allows tasks to run without their own processes or threads by using services that run as background applications<ul>
<li>Code is scheduled and run by the Windows service manager without user input</li>
<li>Similar to a process</li>
</ul>
</li>
<li>Gets “Installed” onto disk/registry</li>
<li>Can interact with them via the service manager (services.exe)<ul>
<li>Start, stop, suspend, schedule, autostart</li>
</ul>
</li>
<li>Some API: CreateService, OpenSCServiceManager, EnumDependentServices</li>
</ul>
<p>Advantages of Malware Using Services</p>
<ul>
<li>One is that services are normally run as SYSTEM or another privileged account.<ul>
<li>This is not a vulnerability because you need administrative access in order to install a service,</li>
<li>but it is convenient for malware writers, because the SYSTEM account has more access than administrator or user accounts.</li>
</ul>
</li>
<li>Services also provide another way to maintain <em>persistence</em> on a system,<ul>
<li>because they can be set to run automatically when the OS starts, and may not even show up in the Task Manager as a process.</li>
</ul>
</li>
<li>A user searching through running applications wouldn’t find anything suspicious<ul>
<li>because the malware isn’t running in a separate process.</li>
</ul>
</li>
</ul>
<p>Different service types</p>
<ul>
<li>The one most commonly used by malware is the <em>WIN32_SHARE_PROCESS</em> type,<ul>
<li>Stores the code for the service in a DLL, and combines several different services <em>in a single, shared process</em>.</li>
<li>In Task Manager, you can find several instances of a process called svchost.exe, which are running WIN32_SHARE_PROCESS-type services.</li>
</ul>
</li>
<li><em>WIN32_OWN_PROCESS</em><ul>
<li>Stores the code in an .exe file and runs as an independent process.</li>
</ul>
</li>
<li>KERNEL_DRIVER<ul>
<li>Loaded code into the kernel.</li>
</ul>
</li>
</ul>
<p>Services and Registry，Each service has a subkey under HKLM\SYSTEM\CurrentControlSet\Services.<br>sc程序是Windows包含的一个命令行工具，可以用来使用它来查看和操作服务。<br>qc命令通过以一个更加可读的方式显示。</p>
<p><code>C:\Users\Useri&gt;sc qc &quot;VMware NAT Service&quot;</code></p>
<p><strong>The Component Object Model</strong></p>
<ul>
<li>The Microsoft Component Object Model (COM) is an interface standard that<ul>
<li>makes it possible for different software components to call each other’s code</li>
<li>without knowledge of specifics about each other.</li>
</ul>
</li>
<li>When analyzing malware that uses COM, you’ll need to be able to determine which code will be run as a result of a COM function call.</li>
</ul>
<p><strong>Exceptions: When Things Go Wrong</strong></p>
<ul>
<li>Exceptions allow a program to handle events outside the flow of normal execution.<ul>
<li>Most of the time, exceptions are caused by errors, such as division by zero.</li>
</ul>
</li>
<li>When an exception occurs, execution transfers to a special routine that resolves the exception.</li>
<li>Some exceptions, such as division by zero, are raised by hardware; others, such as an invalid memory access, are raised by the OS.</li>
<li>You can also raise an exception explicitly in code with the RaiseException call.</li>
</ul>
<h2 id="Kernel-vs-User-Mode-内核与用户模式"><a href="#Kernel-vs-User-Mode-内核与用户模式" class="headerlink" title="Kernel vs. User Mode 内核与用户模式"></a>Kernel vs. User Mode 内核与用户模式</h2><ul>
<li>Windows uses two processor privilege levels: kernel mode and user mode.</li>
<li>All of the functions discussed in this chapter have been usermode functions, but there are kernel-mode equivalent ways of doing the same thing.</li>
<li>Nearly all code runs in user mode, except OS and hardware drivers, which run in kernel mode.</li>
<li>In user mode, each process has its own memory, security permissions, and resources.</li>
<li><em>If a user-mode program executes an invalid instruction and crashes, Windows can reclaim all the resources and terminate the program.</em></li>
</ul>
<p><strong>Malware in the kernel</strong></p>
<ul>
<li>Clearly, malware running in the kernel is considerably more powerful than malware running in user space.</li>
<li>Within kernel space, any distinction between processes running as a privileged or unprivileged user is removed.</li>
<li>Additionally, the OS’s auditing features don’t apply to the kernel.</li>
<li>For these reasons, nearly all rootkits utilize code running in the kernel.</li>
</ul>
<h2 id="Native-API-原生API"><a href="#Native-API-原生API" class="headerlink" title="Native API 原生API"></a>Native API 原生API</h2><ul>
<li>The Native API is a lower-level interface for interacting with Windows<ul>
<li>rarely used by non-malicious programs but is popular among malware writers.</li>
</ul>
</li>
<li>Calling functions in the Native API bypasses the normal Windows API.</li>
</ul>
<p><strong>Bypassing Security Monitoring Program</strong></p>
<h1 id="Chapter8-Debugging"><a href="#Chapter8-Debugging" class="headerlink" title="Chapter8 Debugging"></a>Chapter8 Debugging</h1><h2 id="Debuggers"><a href="#Debuggers" class="headerlink" title="Debuggers"></a>Debuggers</h2><ul>
<li>A debugger is a piece of software or hardware used to test or examine the execution of another program.</li>
<li>Debuggers give you insight into what a program is doing while it is executing.</li>
<li>Debuggers are designed to allow developers to measure and control<ul>
<li>the internal state and</li>
<li>execution of a program.</li>
</ul>
</li>
<li>Debuggers allow you to see<ul>
<li>the value of every memory location, register, and</li>
<li>argument to every function</li>
</ul>
</li>
<li>Debuggers also let you change anything about program execution at any time.</li>
</ul>
<h2 id="Source-Level-vs-Assembly-Level-Debuggers-源代码级与汇编级的调试器"><a href="#Source-Level-vs-Assembly-Level-Debuggers-源代码级与汇编级的调试器" class="headerlink" title="Source-Level vs. Assembly-Level Debuggers 源代码级与汇编级的调试器"></a>Source-Level vs. Assembly-Level Debuggers 源代码级与汇编级的调试器</h2><ul>
<li>source-level debuggers allow a programmer to debug while coding.</li>
<li>Assembly-level debuggers, sometimes called low-level debuggers, operate on assembly code instead of source code<ul>
<li>Malware analysts make heavy use of assembly-level debuggers because they do not require access to a program’s source code.</li>
</ul>
</li>
</ul>
<h2 id="Kernel-vs-User-Mode-Debugging"><a href="#Kernel-vs-User-Mode-Debugging" class="headerlink" title="Kernel vs. User-Mode Debugging"></a>Kernel vs. User-Mode Debugging</h2><ul>
<li>Kernel debugging is performed on two systems because there is only one kernel;<ul>
<li>if the kernel is at a breakpoint, no applications can be running on the system.</li>
<li>One system runs the code that is being debugged, and another runs the debugger.</li>
</ul>
</li>
<li>Additionally, the OS must be configured to allow for kernel debugging, and you must connect the two machines.<ul>
<li>It is possible to run a kernel debugger on the same system as the code being debugged, but it is very uncommon.</li>
<li>A program called <em>SoftICE</em> used to provide this functionality, <em>but it has not been supported since early 2007</em>.</li>
<li>No vendor currently offers a product with this functionality.</li>
</ul>
</li>
</ul>
<p><strong>Different Debuggers</strong></p>
<ul>
<li><em>WinDbg</em> is currently the only popular tool that supports kernel debugging<ul>
<li>It support user mode debugging</li>
</ul>
</li>
<li><em>OllyDbg</em> is the most popular debugger for malware analysts,<ul>
<li>But it does not support kernel debugging.</li>
</ul>
</li>
<li><em>IDA Pro</em> has a built-in debugger, but these do not offer the same features or ease of use as OllyDbg.</li>
</ul>
<h2 id="Using-a-Debugger"><a href="#Using-a-Debugger" class="headerlink" title="Using a Debugger"></a>Using a Debugger</h2><ul>
<li>Single-Stepping 单步调试<ul>
<li>run a single instruction and then return control to the debugger</li>
</ul>
</li>
<li>Stepping-Over 单步跳过<ul>
<li>When you step-over call instructions, you bypass them.</li>
<li>For example, if you step-over a call, the next instruction you will see in your debugger will be the instruction after the function call returns</li>
</ul>
</li>
<li>Stepping-Into 单步跳入<ul>
<li>you step-into a call instruction, the next instruction you will see in the debugger is the first instruction of the called function.</li>
</ul>
</li>
<li>Pausing Execution with Breakpoints<ul>
<li>Breakpoints are used to pause execution and allow you to examine a program’s state.</li>
<li>When a program is paused at a breakpoint, it is referred to as broken.</li>
<li>Breakpoints are needed <ul>
<li>because you can’t access registers or memory addresses while a program is running, since these values are constantly changing.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>Pausing Execution with Breakpoints</strong></p>
<ol>
<li>Software Execution Breakpoints<ul>
<li>The debugger implements a software breakpoint by overwriting the first byte of an instruction with 0xCC, the instruction for INT 3, the breakpoint interrupt designed for use with debuggers.<ul>
<li>The actual memory used by the instruction is changed</li>
<li>The debugger’s memory dump will show the original value</li>
<li>If these bytes change during the execution of the program, the breakpoint will not occur.</li>
</ul>
</li>
<li>When the 0xCC instruction is executed, the OS generates an exception and transfers control to the debugger.</li>
<li>The code change is small and requires only a small amount of memory for recordkeeping in the debugger.</li>
</ul>
</li>
<li>Hardware Execution Breakpoints<ul>
<li>The x86 architecture supports hardware execution breakpoints through dedicated hardware registers.</li>
<li>Every time the processor executes an instruction, there is hardware to detect if the instruction pointer is equal to the breakpoint address.</li>
<li>Unlike software breakpoints, with hardware breakpoints, it doesn’t matter which bytes are stored at that location.<ul>
<li>For example, if you set a breakpoint at address 0x00401234, the processor will break at that location, regardless of what is stored there. </li>
</ul>
</li>
<li>Hardware breakpoints have another advantage over software breakpoints in that they can be set to break on access rather than on execution.<ul>
<li>For example, you can set a hardware breakpoint to break whenever a certain memory location is read or written</li>
<li>Note: OllyDbg support software memory breakpoints</li>
</ul>
</li>
<li>Drawback of Hardware Breakpoints<ul>
<li><em>Only four hardware registers store breakpoint addresses</em></li>
<li>They are easy to modify by the running program.<ul>
<li>There are eight debug registers in the chipset, but only six are used. The first four store breakpoint addresses</li>
<li>Malicious programs can modify these registers, often to interfere with debuggers.</li>
<li>x86 chips have a feature to protect against this.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>Conditional Breakpoints<ul>
<li>Conditional breakpoints are software breakpoints that will break only if a certain condition is true.</li>
<li>The debugger evaluates the condition, and if the condition is not met, it automatically continues execution without alerting the user.</li>
<li>Different debuggers support different conditions.</li>
</ul>
</li>
</ol>
<h2 id="Exceptions"><a href="#Exceptions" class="headerlink" title="Exceptions"></a>Exceptions</h2><ul>
<li>When an exception occurs while a debugger is attached, the program being debugged stops executing, and the debugger is given a first chance at control</li>
<li>The debugger can handle the exception or pass it to the program.<ul>
<li>If the program has a registered exception handler, that is given a chance to handle the exception</li>
<li>after the debugger’s first chance.</li>
</ul>
</li>
<li>If an application does not handle the exception, the debugger is given another chance to handle it<ul>
<li>the second-chance exception.</li>
</ul>
</li>
<li>When the debugger receives a second-chance exception, it means that program would have crashed if the debugger were not attached.</li>
<li>The debugger must resolve the exception to allow the program to run.</li>
</ul>
<p><strong>Common Exceptions</strong></p>
<ul>
<li><em>Single-stepping is also implemented as an exception within the OS.</em></li>
<li>A flag in the flags register called the trap flag is used for single-stepping.</li>
<li>When the trap flag is set, the processor executes one instruction and then generates an exception</li>
<li>A memory-access violation exception is generated when code tries to access a location that it cannot access.<ul>
<li>This exception usually occurs because the memory address is invalid, but it may occur because the memory is not accessible due to access-control protections.</li>
</ul>
</li>
<li>Certain instructions can be executed only when the processor is in privileged mode.<ul>
<li>When the program attempts to execute them outside privileged mode, the processor generates an exception</li>
</ul>
</li>
</ul>
<p><strong>Modifying Execution with a Debugger</strong></p>
<ul>
<li>Debuggers can be used to change program execution.</li>
<li>You can change the control flags, the instruction pointer, or the code itself to modify the way that a program executes</li>
</ul>
<h1 id="To-be-continued！"><a href="#To-be-continued！" class="headerlink" title="To be continued！"></a>To be continued！</h1>
      
    </div><!-- .entry-content -->

    <footer class="entry-meta">
    <a href="/2019/12/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">
    <time datetime="2019-12-26T04:03:34.421Z" class="entry-date">
        2019-12-26
    </time>
</a>
    
    
    </footer>
</article>


    
<nav class="nav-single">
    <h3 class="assistive-text">文章导航</h3>
    
    
        <span class="nav-next"><a href="/2019/11/24/Win%2010%20%E6%A1%8C%E9%9D%A2%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96/" rel="next">Win 10 桌面简单美化 <span class="meta-nav">→</span></a></span>
    
</nav><!-- .nav-single -->







</div></div>
        <div id="secondary" class="widget-area" role="complementary">
  
    <aside id="search" class="widget widget_search"><form role="search" method="get" accept-charset="utf-8" id="searchform" class="searchform" action="//google.com/search">
    <div>
        <input type="text" value="" name="s" id="s" />
        <input type="submit" id="searchsubmit" value="搜索" />
    </div>
</form></aside>
  
    
  
    
  
    
  <aside class="widget">
    <h3 class="widget-title">Recents</h3>
    <div class="widget-content">
      <ul>
        
          <li>
            <a href="/2019/12/26/%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90%E5%AE%9E%E6%88%98%E7%AC%94%E8%AE%B0/">恶意代码分析实战笔记</a>
          </li>
        
          <li>
            <a href="/2019/11/24/Win%2010%20%E6%A1%8C%E9%9D%A2%E7%AE%80%E5%8D%95%E7%BE%8E%E5%8C%96/">Win 10 桌面简单美化</a>
          </li>
        
          <li>
            <a href="/2019/11/19/WireShark%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/">WireShark基本使用教程</a>
          </li>
        
          <li>
            <a href="/2019/10/30/Sublime%20text%203%20%E7%9A%84%E4%BD%BF%E7%94%A8/">Sublime text 3 的使用</a>
          </li>
        
          <li>
            <a href="/2019/10/29/First-blog/">First blog</a>
          </li>
        
      </ul>
    </div>
  </aside>

  
    
  
    
  
</div>
      </div>
      <footer id="colophon" role="contentinfo">
    <p>&copy; 2019 shengjia
    All rights reserved.</p>
    <p>Powered by <a href="http://hexo.io/" target="_blank">Hexo</a></p>
</footer>
    <script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"1","bdMiniList":false,"bdPic":"","bdStyle":"2","bdSize":"16"},"share":{}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='/js/share.js'];</script>

<script src="/js/jquery-3.3.1.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

<script src="/js/navigation.js"></script>

<div id="bg"></div>

  </div>
<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"left","width":180,"height":210},"mobile":{"show":false},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/love.js"></script>

<!--单击显示文字-->
<script type="text/javascript" src="/js/click_show_text.js"></script>
